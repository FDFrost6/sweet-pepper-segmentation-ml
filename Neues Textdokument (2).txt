import numpy as np
from skimage.color import rgb2lab

class GaussianPaprikaSegmenter:
    def __init__(self, color_space="rgb", reg=1e-6):
        """
        color_space: "rgb" oder "lab"
        reg: Regularisierungsterm, um Kovarianzmatrizen invertierbar zu halten
        """
        self.color_space = color_space
        self.reg = reg
        
        # Parameter, die wir schätzen:
        self.mu0 = None      # Mittelwert für Klasse 0 (Rest)
        self.mu1 = None      # Mittelwert für Klasse 1 (Paprika)
        self.S0  = None      # Kovarianzmatrix für Klasse 0
        self.S1  = None      # Kovarianzmatrix für Klasse 1
        self.p0  = None      # Prior P(y=0)
        self.p1  = None      # Prior P(y=1)

    def _preprocess(self, X):
        """
        X: np.ndarray, Form (N,3), dtype uint8 0–255
        return: np.ndarray (N,d) mit d=1 (rgb) oder d=2 (lab: a,b)
        """
        Xf = X.astype(np.float32) / 255.0
        if self.color_space == "lab":
            # RGB -> LAB, dann nur a- und b-Kanal
            lab = rgb2lab(Xf.reshape(-1,1,3)).reshape(-1,3)
            return lab[:,1:3]        # (N,2)
        else:
            # Nur roher R-Kanal
            return Xf[:,0].reshape(-1,1)  # (N,1)

    def fit(self, X, y):
        """
        Schätzt mu0, mu1, S0, S1 und priors.
        X: (N,3) RGB-Pixel
        y: (N,) Labels 0 oder 1
        """
        F = self._preprocess(X)         # (N,d)
        # Splits
        F0 = F[y==0]
        F1 = F[y==1]
        N0 = len(F0)
        N1 = len(F1)
        N  = N0 + N1

        # Priors
        self.p0 = N0 / N
        self.p1 = N1 / N

        # Mittelwerte
        self.mu0 = F0.mean(axis=0)
        self.mu1 = F1.mean(axis=0)

        # Kovarianzen + Regularisierung
        # rowvar=False: Spalten sind Features
        self.S0 = np.cov(F0, rowvar=False) + np.eye(F.shape[1])*self.reg
        self.S1 = np.cov(F1, rowvar=False) + np.eye(F.shape[1])*self.reg

    def _mv_gauss_pdf(self, X, mu, S):
        """
        Multivariate Normalverteilungsdichte.
        X: (M,d), mu: (d,), S: (d,d)
        return: (M,) pdf-Werte
        """
        d = mu.size
        invS = np.linalg.inv(S)
        detS = np.linalg.det(S)
        norm = 1.0 / np.sqrt((2*np.pi)**d * detS)
        diff = X - mu
        expo = -0.5 * np.sum(diff.dot(invS) * diff, axis=1)
        return norm * np.exp(expo)

    def predict_proba(self, X):
        """
        Gibt ein Array (M,2) zurück:
          Spalte0 = P(y=0|X), Spalte1 = P(y=1|X)
        """
        F = self._preprocess(X)  # (M,d)
        # Likelihood * Prior
        L0 = self._mv_gauss_pdf(F, self.mu0, self.S0) * self.p0
        L1 = self._mv_gauss_pdf(F, self.mu1, self.S1) * self.p1
        S  = L0 + L1 + 1e-12
        return np.vstack([L0/S, L1/S]).T

    def predict(self, X, thresh=0.5):
        """
        Harte Entscheidung: Klasse=1, wenn P(y=1|x)>=thresh
        """
        probs = self.predict_proba(X)[:,1]
        return (probs >= thresh).astype(int)
